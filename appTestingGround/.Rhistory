data.frame(
visitID = rep('REITBOBMD1',3),
date = rep(Sys.Date(), 3),
obs = rep('bse', 3),
startTime = 05:13,
interval = 1:3,
spp = 'ABDU'
d0_10 = c(5, 0, 59),
d10_20 = c(5, 0, 59),
d20_30 = c(5, 0, 59),
d30_40 = c(5, 0, 59),
d40_50 = c(5, 0, 59),
detection = c('V', 'A', 'B')
)
data.frame(
visitID = rep('REITBOBMD1',3),
date = rep(Sys.Date(), 3),
obs = rep('bse', 3),
startTime = 05:13,
interval = 1:3,
spp = 'ABDU',
d0_10 = c(5, 0, 59),
d10_20 = c(5, 0, 59),
d20_30 = c(5, 0, 59),
d30_40 = c(5, 0, 59),
d40_50 = c(5, 0, 59),
detection = c('V', 'A', 'B')
)
pcTableWeb <- data.frame(
visitID = rep('REITBOBMD1',3),
date = rep(Sys.Date(), 3),
obs = rep('bse', 3),
startTime = 05:13,
interval = 1:3,
spp = 'ABDU',
d0_10 = c(5, 0, 59),
d10_20 = c(5, 0, 59),
d20_30 = c(5, 0, 59),
d30_40 = c(5, 0, 59),
d40_50 = c(5, 0, 59),
detection = c('V', 'A', 'B')
)
getwd()
# 'C:/Users/EvansBr/Desktop/gits/Nestwatch/nnDataEntryApp'
setwd('C:/Users/EvansBr/Desktop/gits/Nestwatch/nnDataEntryApp')
setwd('C:/Users/EvansBr/Desktop/gits/Nestwatch/nnDataEntryApp/startData')
write_csv(siteIdTableWeb, 'siteIdTable.csv')
write_csv(siteLocationTableWeb, 'siteLocationTable.csv')
write_csv(visitTableWeb, 'visitTable.csv')
write_csv(captureTableWeb, 'captureTable.csv')
write_csv(resightEffortTableWeb, 'resightEffortTable.csv')
write_csv(resightTechTableWeb, 'resightTechTable.csv')
write_csv(pcTableWeb, 'pcTable.csv')
captureTableWeb
captureTableWeb %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR)
captureTableWeb %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR) %>%
distinct
captureTableWeb
captureTableWeb %>%
filter(enc == 'B')
captureTableWeb %>%
filter(enc == 'B') %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR) %>%
distinct
captureTableWeb %>%
filter(enc == 'B') %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR) %>%
distinct %>%
mutate(year = year(dateVisit))
captureTableWeb %>%
filter(enc == 'B') %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR) %>%
distinct %>%
mutate(year = year(dateVisit)) %>%
select(-dateVisit) %>%
select(siteID, spp, year, bandNumber, colorL, colorR) %>%
arrange(siteID, spp, year)
queryTableWeb <- captureTableWeb %>%
filter(enc == 'B') %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR) %>%
distinct %>%
mutate(year = year(dateVisit)) %>%
select(-dateVisit) %>%
select(siteID, spp, year, bandNumber, colorL, colorR) %>%
arrange(siteID, spp, year)
write_csv(queryTableWeb, 'queryTable.csv')
queryTableWeb <- captureTableWeb %>%
filter(enc == 'B') %>%
select(siteID, dateVisit, spp, bandNumber, colorL, colorR) %>%
distinct %>%
mutate(year = year(dateVisit)) %>%
select(-dateVisit) %>%
select(siteID, spp, year, bandNumber, colorL, colorR) %>%
arrange(siteID, spp, year)
write_csv(queryTableWeb, 'queryTable.csv')
# Script to generate color combinations.
#===============================================================================*
# ---- SET UP ----
#===============================================================================*
# Smart installer will check list of packages that are installed, install any
# necessary package that is missing, and load the library:
smartInstallAndLoad <- function(packageVector){
for(i in 1:length(packageVector)){
package <- packageVector[i]
if(!package %in% rownames(installed.packages())){
install.packages(packageVector[i],repos="http://cran.rstudio.com/",
dependencies=TRUE)
}
}
lapply(packageVector, library, character.only = TRUE)
}
# Load and potentially install libraries:
smartInstallAndLoad(c('tidyverse', 'stringr', 'lubridate'))
#===============================================================================*
# ---- FUNCTIONS ----
#===============================================================================*
# Function to generate color combinations:
# Inputs are:
# - colorVector: A vector of colors (does not include aluminum)
# - nBands: The number of total bands (including aluminum)
# - xPositions: The location of the aluminum band (defaults to any):
#     * 1 = Left leg, top
#     * 2 = Left leg, bottom
#     * 3 = Right leg, top
#     * 4 = Right leg, bottom
# - aluminum: TRUE/FALSE (defaults to TRUE), whether you want combinations
#      that include an aluminum band
getColorCombos <- function(colorVector, nBands,
xPositions = 1:4, aluminum = TRUE){
if(aluminum == TRUE) colorVector <- c(colorVector, 'X')
if(nBands!= 4) colorVector <- c(colorVector, '-')
colorList <- rep(list(colorVector), 4)
colorGrid <- expand.grid(colorList, stringsAsFactors = FALSE) %>%
unite(col = combinedCol, 1:4, sep = '') %>%
filter(str_count(combinedCol, '-') == 4 - nBands)
if(aluminum == TRUE){
colorGrid <- colorGrid %>%
filter(str_count(combinedCol, 'X') == 1,
str_locate(combinedCol, 'X')[,1] %in% xPositions)
}
colorCombos <- colorGrid %>%
separate(col = combinedCol, into = c('colorL', 'colorR'), sep = 2) %>%
mutate_all(str_replace_all, pattern = '-', replacement = '')
return(
sample_n(colorCombos, nrow(colorCombos)) %>%
distinct
)
}
# Function to return a data frame of color combos, given a data frame of used
# combos. Inputs include:
# - colorComboFrame: Generated color combination data frame from output of
#   getColorCombos, with the columns colorL and colorR
# - previousComboFrame: Data frame of used color combinations with the
#   columns colorL and colorR
getUnusedCombos <- function(colorComboFrame, previousComboFrame){
newCombos <- colorComboFrame %>%
anti_join(
previousComboFrame,
by = c('colorL', 'colorR')
)
return(
sample_n(newCombos, nrow(newCombos))
)
}
# Function to return a data frame of color combos, given a data frame of combos
# used and the last date in which a bird was observed. Inputs include:
# - colorComboFrame: Generated color combination data frame from output of
#   getColorCombos, with the columns colorL and colorR
# - comboDateFrame: Data frame of used color combinations with the
#   columns colorL and colorR and a date column (ISO 8601) with the last
#   date a bird was observed
# - yearBuffer: The number of years in which a color combination should be
#   exclude. This buffer is designed as "less than or equal to" so if, for
#   example, the year buffer is 3, the output would exlude any combination
#   used in the last 3 years.
getCombosByYearBuffer <- function(colorComboFrame, comboDateFrame, yearBuffer){
currentYear <- year(Sys.Date())
combosToExclude <- comboDateFrame %>%
filter(currentYear - year(date) <= yearBuffer)
return(
getUnusedCombos(colorComboFrame, combosToExclude)
)
}
#===============================================================================*
# ---- TRYING IT OUT ----
#===============================================================================*
# Blue Jay color vector:
jayColors <- c('B', 'G', 'O', 'Y', 'R','W')
# Get 4 band combination, with aluminum on the bottom:
jayCombos <- getColorCombos(jayColors, nBands = 4, xPositions = c(2,4))
# Non-native species? Don't use aluminum:
getColorCombos(jayColors, nBands = 4, aluminum = FALSE)
# Only three bands (with alumnimum on bottom):
getColorCombos(jayColors, nBands = 3, xPositions = c(2,4))
# Only three bands with aluminum at any position:
getColorCombos(jayColors, nBands = 3)
#-------------------------------------------------------------------------------*
# ---- TRYING IT OUT: UNUSED COMBOS ----
#-------------------------------------------------------------------------------*
# Let's use our jay combinations:
jayCombos <- getColorCombos(jayColors, nBands = 4, xPositions = c(2,4))
# And make a fake data frame of used combos:
usedCombos <- jayCombos %>%
sample_n(100)
# We can use the getUnusedCombos function to get new combos:
newCombos <- getUnusedCombos(jayCombos, usedCombos)
# Let's see:
nrow(jayCombos)
nrow(usedCombos)
nrow(newCombos)
#-------------------------------------------------------------------------------*
# ---- TRYING IT OUT: NEW COMBOS AFTER A GIVEN NUMBER OF YEARS ----
#-------------------------------------------------------------------------------*
# Let's use our jay combinations again:
jayCombos <- getColorCombos(jayColors, nBands = 4, xPositions = c(2,4))
# I'm going to add a column of fake dates that represent the last day the jay
# was observed:
jayCombosDate <- jayCombos %>%
mutate(date = sample(seq(as.Date('2005-01-01'),
Sys.Date(), by="day"), nrow(jayCombos))
)
# Now we can simply run the function to determine the combos that can be
# used:
getCombosByYearBuffer(jayCombos, jayCombosDate, yearBuffer = 5)
# Did it work? Let's check:
nrow(jayCombos)
jayCombosDate %>%
filter(year(Sys.Date()) - year(date) > 5) %>%
nrow
getCombosByYearBuffer(jayCombos, jayCombosDate, yearBuffer = 5) %>%
nrow
# Yup!
#-------------------------------------------------------------------------------*
# ---- WRITING YOUR COMBOS FILE TO YOUR WORKING DIRECTORY ----
#-------------------------------------------------------------------------------*
# If you're satisfied with your color combinations, write them to a csv file to
# print them out (from Excel ... blech):
write_csv(
getCombosByYearBuffer(jayCombos,
jayCombosDate,
yearBuffer = 5),
'jayCombos.csv'
)
captureTableWeb
captureTableWeb %>%
select(colorL, colorR)
captureTableWeb %>%
filter(spp == 'NOCA')
captureTableWeb %>%
filter(spp == 'NOCA') %>%
select(colorL, colorR)
colors <- c('K', 'B', 'N', 'G', 'E', 'O', 'P', 'M', 'R', 'W', 'Y')
potentialColors <- getColorCombos(colors, nBands = 3)
potentialColors
potentialCombos <- getColorCombos(colors, nBands = 3)
usedCombos <- captureTableWeb %>%
filter(spp == 'NOCA') %>%
select(colorL, colorR) %>%
distinct
newCombos <- getUnusedCombos(potentialCombos, usedCombos)
newCombos
getUnusedCombos <- function(colorComboFrame, previousComboFrame){
newCombos <- colorComboFrame %>%
anti_join(
previousComboFrame,
by = c('colorL', 'colorR')
)
return(
sample_n(newCombos, nrow(newCombos)) %>%
distinct
)
}
getCombosByYearBuffer <- function(colorComboFrame, comboDateFrame, yearBuffer){
currentYear <- year(Sys.Date())
combosToExclude <- comboDateFrame %>%
filter(currentYear - year(date) <= yearBuffer)
return(
getUnusedCombos(colorComboFrame, combosToExclude) %>%
distinct
)
}
newCombos <- getUnusedCombos(potentialCombos, usedCombos)
newCombos
colors <- c('K', 'B', 'G', 'O', 'P', 'M', 'R', 'W', 'Y')
potentialCombos <- getColorCombos(colors, nBands = 3)
usedCombos <- captureTableWeb %>%
filter(spp == 'NOCA') %>%
select(colorL, colorR) %>%
distinct
newCombos <- getUnusedCombos(potentialCombos, usedCombos)
newCombos
usedCombos <- captureTableWeb %>%
filter(spp == 'GRCA') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
captureTableWeb %>%
filter(spp == 'GRCA') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
usedCombos <- captureTableWeb %>%
filter(spp == 'GRCA') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
usedCombos <- captureTableWeb %>%
filter(spp == 'AMRO') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
usedCombos <- captureTableWeb %>%
filter(spp == 'CACH') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
usedCombos <- captureTableWeb %>%
filter(spp == 'CARW') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
usedCombos <- captureTableWeb %>%
filter(spp == 'HOWR') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
usedCombos <- captureTableWeb %>%
filter(spp == 'SOSP') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
potentialCombos <- getColorCombos(colors, nBands = 4)
usedCombos <- captureTableWeb %>%
filter(spp == 'SOSP') %>%
select(colorL, colorR) %>%
distinct
getUnusedCombos(potentialCombos, usedCombos)
write_csv(captureTableWeb, 'captureTable.csv')
captureTableWeb
siteIdTableWeb
library(markdown)
library(shiny)
library(dplyr)
library(tidyr)
library(stringr)
library(shinyBS)
library(R.utils)
# library(rdrop2)
# library(googlesheets)
library(DT)
library(shinyjs)
library(mongolite)
smartInstallAndLoad(c('tidyverse', 'stringr', 'lubridate',
'shinyBS', 'R.utils','DT', 'shinyjs',
'mongolite'))
install.packages(packageVector[i], repos = "http://cran.rstudio.com/",
install.packages('mongolite')
mongoUrl <- 'mongodb://bsevans:33shazam@ds025232.mlab.com:25232/nndataentry'
aouCodes <- mongoToTblDf(
mongo('aou_codes', url = mongoUrl)$find()
)
siteNameSubsetter <- function(inHub){
encounters %>%
select(hub, site) %>%
distinct %>%
bind_rows(
data.frame(hub = c('DC', 'Atlanta', 'Gainesville',
'Pittsburgh', 'Raleigh', 'Springfield'),
site = rep('', 6))) %>%
filter(hub == inHub) %>%
arrange(site) %>%
.$site
}
# Function assigns fancy column headers to the field codes:
getTableMetadata <- function(fieldCodes, fieldNames) {
fields <- fieldNames
names(fields) <- fieldCodes
result <- list(fields = fields)
return (result)
}
# Function takes values of inputs, if there are any, and puts them in a 1-row data frame:
castData <- function(fieldValues){
return(data.frame(t(as.list(fieldValues)),
stringsAsFactors = FALSE))
}
# Make some submissions blank:
createBlankInputs <- function(fieldCodes, session){
for(i in 1:length(fieldCodes)){
updateTextInput(session, fieldCodes[i], value = '')
}
}
# Adding or modifying records:
dataAddOrModify <- function(df, rowSelected, formOutput){
# If the data frame is empty for  a given site:
if(length(df) == 0){
df <- castData(formOutput)
} else {
# If a row has not been selected, add row:
if(length(rowSelected) < 1){
df[nrow(df) + 1,] <- castData(formOutput)
# If a row has been selected replace row:
} else {
df[rowSelected,] <- castData(formOutput)
}
}
return(df)
}
# Update the field inputs on the ui:
updateInputs <- function(data, fieldCodes, session) {
for(i in 1:length(fieldCodes)){
updateTextInput(
session, fieldCodes[i],
value = unname(data[fieldCodes[i]])
)
}
}
# Show selected record in inputs:
# showRecordInputs <- function(data, rowSelected, fieldCodes, session){
#   if (length(rowSelected) == 1){
#     updateInputs(data[rowSelected,], fieldCodes, session)
#   }
# }
showRecordInputs <- function(data, rowSelected, fieldCodes, session){
if (length(rowSelected) == 1){
fieldValues <- data[rowSelected,]
for(i in 1:length(fieldCodes)){
updateTextInput(
session, fieldCodes[i],
value = unname(fieldValues[i])
)
}
}
}
# Delete a selected row:
deleteRecord <- function(df, rowSelected){
if(length(rowSelected == 1)){
return(df[-rowSelected,])
createBlankInputs(blankFieldsEnc, session)
}
}
# Query mongo by site:
siteQuery <- function(siteField, inSite){
str_c('{',
shQuote(siteField, type = 'cmd'),
':',
shQuote(inSite, type = 'cmd'),
'}')
# ', "_id" : 0}')
}
# Query mongo by hub:
hubQuery <- function(hubField, inHub){
str_c('{',
shQuote(hubField, type = 'cmd'),
':',
shQuote(inHub, type = 'cmd'),
'}')
}
hubSiteQuery <- function(inHub, inSite){
str_c('{"hub":',
shQuote(inHub, type = 'cmd'),
', "site":',
shQuote(inSite, type = 'cmd'),
'}'
)
}
# Convert mongo data frame to a dplyr table dataframe
mongoToTblDf <- function(data){
#   hubs <- unlist(unique(data$hub))
#   hubList <- vector('list', length = length(hubs))
#   for(i in 1:length(hubs)){
#     dataHubSubset <- data[data$hub == hubs[i],]
# for(i in 1:nrow(dataHubSubset)){
if(nrow(data) > 0 & ncol(data) > 0){
for(j in 1:ncol(data)){
data[,j] <- as.character(data[,j])
# }
}
data <- data %>% tbl_df
}
data
# hubList[[i]] <- dataHubSubset
# }
# bind_rows(hubList) %>% tbl_df
}
emptyDataFrame <- function(fieldCodes){
matrix(nrow = 0,
ncol = length(fieldCodes)) %>%
data.frame %>%
setNames(fieldCodes)
}
# exampleFrame <- data.frame(hub = c('a', 'b'), obs1 = c(1,2), obs2 = c(2,1))
# here's what i'm thinking ... data where there is a null value for a given field eliminates the field ... perhaps this should be come a table data frame after bind it with a data frame that's blank but defined by the proper fields.
getwd()
setwd('C:/Users/EvansBr/Desktop/gits/Nestwatch/nnDataEntryApp2017')
source('helperFunctions.R', local=TRUE)
mongoUrl <- 'mongodb://bsevans:33shazam@ds025232.mlab.com:25232/nndataentry'
aouCodes <- mongoToTblDf(
mongo('aou_codes', url = mongoUrl)$find()
)
library(mongolite)
install.packages('jsonlite')
install.packages("jsonlite")
library(jsonlite)
aouCodes <- mongoToTblDf(
mongo('aou_codes', url = mongoUrl)$find()
)
library(mongo)
library(mongolite)
install.packages('mongolite')
install.packages("mongolite")
